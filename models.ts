// ---------------------------
// This file was generated by Nango (v0.57.6)
// It's recommended to version this file
// https://nango.dev
// ---------------------------

// ------ Models
export interface GithubRepositoryInput {
  owner: string;
  repo: string;
};

export interface GithubRepository {
  id: number;
  name: string;
  full_name: string;
  private: boolean;
  html_url: string;
  description: string;
  fork: boolean;
  url: string;
  created_at: string;
  updated_at: string;
  pushed_at: string;
  git_url: string;
  ssh_url: string;
  clone_url: string;
  language: string;
  default_branch: string;
  open_issues_count: number;
  topics: string[];
  visibility: string;
};

export interface GithubRepositoryList {
  repositories: GithubRepository[];
};

export interface GithubCreateRepositoryInput {
  name: string;
  description?: string;
  private?: boolean;
  has_issues?: boolean;
  has_projects?: boolean;
  has_wiki?: boolean;
  auto_init?: boolean;
  gitignore_template?: string;
  license_template?: string;
};

export interface GithubUpdateRepositoryInput {
  owner: string;
  repo: string;
  name?: string;
  description?: string;
  private?: boolean;
  has_issues?: boolean;
  has_projects?: boolean;
  has_wiki?: boolean;
  default_branch?: string;
};

export interface GithubDeleteRepositoryOutput {
  success: boolean;
  message: string;
};

export interface GithubIssuesInput {
  owner: string;
  repo: string;
  state?: string;
  sort?: string;
  direction?: string;
  per_page?: number;
  page?: number;
};

export interface GithubIssueInput {
  owner: string;
  repo: string;
  issue_number: number;
};

export interface GithubIssueCreator {
  id: number;
  login: string;
  avatar_url: string;
  html_url: string;
};

export interface GithubIssueLabel {
  id: number;
  name: string;
  color: string;
  description: string;
};

export interface GithubIssueAssignee {
  id: number;
  login: string;
  avatar_url: string;
  html_url: string;
};

export interface GithubIssue {
  id: number;
  number: number;
  title: string;
  state: string;
  locked: boolean;
  body: string;
  user: GithubIssueCreator;
  labels: GithubIssueLabel[];
  assignees: GithubIssueAssignee[];
  created_at: string;
  updated_at: string;
  closed_at: string;
  comments: number;
  html_url: string;
};

export interface GithubIssueList {
  issues: GithubIssue[];
};

export interface GithubCreateIssueInput {
  owner: string;
  repo: string;
  title: string;
  body?: string;
  assignees?: string[];
  labels?: string[];
};

export interface GithubUpdateIssueInput {
  owner: string;
  repo: string;
  issue_number: number;
  title?: string;
  body?: string;
  state?: string;
  assignees?: string[];
  labels?: string[];
};

export interface GithubUser {
  id: number;
  login: string;
  avatar_url: string;
  html_url: string;
};

export interface GithubLabel {
  id: number;
  name: string;
  color: string;
  description: string;
};

export interface Attachments {
  filename: string;
  mimeType: string;
  size: number;
  attachmentId: string;
};

export interface GmailDraftInput {
  recipient: string;
  subject: string;
  body?: string;
  headers?: Record<string, any>;
};

export interface GmailDraftOutput {
  id: string;
  threadId: string | null;
};

export interface GmailReplyDraftInput {
  sender: string;
  subject: string;
  body: string;
  threadId: string;
  messageId: string;
  inReplyTo: string;
  references: string;
  date: string;
  replyBody: string;
};

export interface GmailReplyDraftOutput {
  id: string;
  threadId: string | null;
};

export interface GmailListMessagesInput {
  maxResults?: number;
  labelIds?: string[];
  q?: string;
  pageToken?: string;
};

export interface GmailMessageMetadata {
  id: string;
  threadId: string;
  labelIds?: string[];
  snippet?: string;
};

export interface GmailMessageList {
  messages: GmailMessageMetadata[];
  nextPageToken?: string;
};

export interface GmailGetMessageInput {
  id: string;
  format?: string;
};

export interface GmailHeader {
  name: string;
  value: string;
};

export interface GmailAttachmentInfo {
  filename: string;
  mimeType: string;
  size: number;
  attachmentId?: string;
};

export interface GmailMessage {
  id: string;
  threadId: string;
  labelIds?: string[];
  snippet?: string;
  payload: Record<string, any>;
  sizeEstimate: number;
  historyId: string;
  internalDate: string;
  headers?: GmailHeader[];
  body?: string;
  mimeType?: string;
  filename?: string;
  attachments?: GmailAttachmentInfo[];
};

export interface GmailSearchMessagesInput {
  q: string;
  maxResults?: number;
  labelIds?: string[];
  pageToken?: string;
};

export interface GmailAttachment {
  filename: string;
  content: string;
  mimeType: string;
};

export interface GmailSendEmailInput {
  to: string;
  subject: string;
  body: string;
  from?: string;
  cc?: string;
  bcc?: string;
  attachments?: GmailAttachment[];
};

export interface GmailSendEmailOutput {
  id: string;
  threadId: string;
  labelIds?: string[];
};

export interface GoogleCalendarList {
  calendars: ({  id: string;
  summary: string;
  description?: string;
  location?: string;
  timeZone: string;
  accessRole: string;
  primary: boolean;
  backgroundColor?: string;
  foregroundColor?: string;})[];
  nextPageToken?: string;
};

export interface GoogleCalendarEventsInput {
  calendarId: string;
  timeMin?: string;
  timeMax?: string;
  maxResults?: number;
  pageToken?: string;
  orderBy?: string;
  q?: string;
  singleEvents?: boolean;
  timeZone?: string;
};

export interface GoogleCalendarEventList {
  events: ({  id: string;
  summary: string;
  description?: string;
  location?: string;
  start: {  dateTime?: string;
  date?: string;
  timeZone?: string;};
  end: {  dateTime?: string;
  date?: string;
  timeZone?: string;};
  status: string;
  creator: {  id?: string;
  email: string;
  displayName?: string;
  self?: boolean;};
  organizer: {  id?: string;
  email: string;
  displayName?: string;
  self?: boolean;};
  attendees?: ({  id?: string;
  email: string;
  displayName?: string;
  responseStatus: string;
  optional?: boolean;
  resource?: boolean;
  comment?: string;})[];
  htmlLink: string;
  created: string;
  updated: string;
  recurrence?: string[];})[];
  nextPageToken?: string;
  timeZone: string;
};

export interface GoogleCalendarEventInput {
  summary: string;
  description?: string;
  location?: string;
  start: string;
  end: string;
  timeZone?: string;
  attendees?: string[];
};

export interface GoogleCalendarEventUpdateInput {
  eventId: string;
  summary?: string;
  description?: string;
  location?: string;
  start?: string;
  end?: string;
  timeZone?: string;
  attendees?: string[];
  sendUpdates?: string;
};

export interface GoogleCalendarEventOutput {
  id: string;
  htmlLink: string;
  status: string;
  created: string;
};

export interface SheetRow {
  cells: string[];
};

export interface SheetData {
  rows: SheetRow[];
};

export interface GoogleSheetTab {
  title: string;
  data?: SheetData;
};

export interface GoogleSheetCreateInput {
  title: string;
  sheets?: GoogleSheetTab[];
};

export interface GoogleSheetCreateOutput {
  id: string;
  url: string;
  title: string;
};

export interface SheetUpdate {
  sheetId?: number;
  sheetName?: string;
  range?: string;
  startRow?: number;
  startColumn?: number;
  data: SheetData;
};

export interface GoogleSheetUpdateInput {
  spreadsheetId: string;
  updates: SheetUpdate[];
};

export interface GoogleSheetUpdateOutput {
  spreadsheetId: string;
  updatedRange: string;
  updatedRows: number;
  updatedColumns: number;
  updatedCells: number;
};

export interface TwitterPostInput {
  text: string;
  reply_to?: string;
  quote?: string;
};

export interface TwitterPostOutput {
  id: string;
  text: string;
  created_at: string;
};

export interface ReferencedTweet {
  type: string;
  id: string;
};

export interface TweetMetrics {
  retweet_count: number;
  reply_count: number;
  like_count: number;
  quote_count: number;
};

export interface TwitterUserProfile {
  id: string;
  name: string;
  username: string;
  profile_image_url: string;
  description: string;
  location: string;
  url: string;
  protected: boolean;
  verified: boolean;
  followers_count: number;
  following_count: number;
  tweet_count: number;
  listed_count: number;
};

export interface LinkedInUserProfile {
  sub: string;
  email_verified: boolean;
  name: string;
  locale: Record<string, any>;
  given_name: string;
  family_name: string;
  email: string;
  picture: string;
};

export interface GoogleDriveDocument {
  id: string;
  name: string;
  mimeType: string;
  webViewLink: string;
  modifiedTime: string;
  createdTime: string;
  parents: string[];
  size: string;
};

export interface GoogleDriveFolder {
  id: string;
  name: string;
  mimeType: string;
  webViewLink: string;
  modifiedTime: string;
  createdTime: string;
  parents: string[];
};

export interface ListDocumentsInput {
  folderId?: string;
  mimeType?: string;
  pageSize?: number;
  pageToken?: string;
  orderBy?: string;
};

export interface GoogleDriveDocumentList {
  documents: GoogleDriveDocument[];
  nextPageToken?: string;
};

export interface GoogleDriveFolderList {
  folders: GoogleDriveFolder[];
  nextPageToken?: string;
};
// ------ /Models

// ------ SDK

import type { Nango } from '@nangohq/node';
import type { AxiosInstance, AxiosInterceptorManager, AxiosRequestConfig, AxiosResponse, AxiosError } from 'axios';
import type { ApiEndUser, DBSyncConfig, DBTeam, GetPublicIntegration, HTTP_METHOD, RunnerFlags } from '@nangohq/types';
import type { ZodSchema, SafeParseSuccess } from 'zod';

export declare const oldLevelToNewLevel: {
    readonly debug: 'debug';
    readonly info: 'info';
    readonly warn: 'warn';
    readonly error: 'error';
    readonly verbose: 'debug';
    readonly silly: 'debug';
    readonly http: 'info';
};
type LogLevel = 'info' | 'debug' | 'error' | 'warn' | 'http' | 'verbose' | 'silly';
interface Pagination {
    type: string;
    limit?: number;
    response_path?: string;
    limit_name_in_request: string;
    in_body?: boolean;
}
interface CursorPagination extends Pagination {
    cursor_path_in_response: string;
    cursor_name_in_request: string;
}
interface LinkPagination extends Pagination {
    link_rel_in_response_header?: string;
    link_path_in_response_body?: string;
}
interface OffsetPagination extends Pagination {
    offset_name_in_request: string;
    offset_start_value?: number;
    offset_calculation_method?: 'per-page' | 'by-response-size';
}
interface RetryHeaderConfig {
    at?: string;
    after?: string;
}
export interface ProxyConfiguration {
    endpoint: string;
    providerConfigKey?: string;
    connectionId?: string;
    method?: 'GET' | 'POST' | 'PATCH' | 'PUT' | 'DELETE' | 'get' | 'post' | 'patch' | 'put' | 'delete';
    headers?: Record<string, string>;
    params?: string | Record<string, string | number>;
    data?: unknown;
    retries?: number;
    baseUrlOverride?: string;
    paginate?: Partial<CursorPagination> | Partial<LinkPagination> | Partial<OffsetPagination>;
    retryHeader?: RetryHeaderConfig;
    responseType?: 'arraybuffer' | 'blob' | 'document' | 'json' | 'text' | 'stream' | undefined;
    retryOn?: number[] | null;
}
export interface AuthModes {
    OAuth1: 'OAUTH1';
    OAuth2: 'OAUTH2';
    OAuth2CC: 'OAUTH2_CC';
    Basic: 'BASIC';
    ApiKey: 'API_KEY';
    AppStore: 'APP_STORE';
    Custom: 'CUSTOM';
    App: 'APP';
    None: 'NONE';
    TBA: 'TBA';
    Tableau: 'TABLEAU';
    Jwt: 'JWT';
    Bill: 'BILL';
    TwoStep: 'TWO_STEP';
    Signature: 'SIGNATURE';
}
export type AuthModeType = AuthModes[keyof AuthModes];
interface OAuth1Token {
    oAuthToken: string;
    oAuthTokenSecret: string;
}
interface AppCredentials {
    type: AuthModes['App'];
    access_token: string;
    expires_at?: Date | undefined;
    raw: Record<string, any>;
}
interface AppStoreCredentials {
    type?: AuthModes['AppStore'];
    access_token: string;
    expires_at?: Date | undefined;
    raw: Record<string, any>;
    private_key: string;
}
interface BasicApiCredentials {
    type: AuthModes['Basic'];
    username: string;
    password: string;
}
interface ApiKeyCredentials {
    type: AuthModes['ApiKey'];
    apiKey: string;
}
interface CredentialsCommon<T = Record<string, any>> {
    type: AuthModeType;
    raw: T;
}
interface OAuth2Credentials extends CredentialsCommon {
    type: AuthModes['OAuth2'];
    access_token: string;
    refresh_token?: string;
    expires_at?: Date | undefined;
}
interface OAuth2ClientCredentials extends CredentialsCommon {
    type: AuthModes['OAuth2CC'];
    token: string;
    expires_at?: Date | undefined;
    client_id: string;
    client_secret: string;
}
interface OAuth1Credentials extends CredentialsCommon {
    type: AuthModes['OAuth1'];
    oauth_token: string;
    oauth_token_secret: string;
}
interface TbaCredentials {
    type: AuthModes['TBA'];
    token_id: string;
    token_secret: string;
    config_override: {
        client_id?: string;
        client_secret?: string;
    };
}
interface TableauCredentials extends CredentialsCommon {
    type: AuthModes['Tableau'];
    pat_name: string;
    pat_secret: string;
    content_url?: string;
    token?: string;
    expires_at?: Date | undefined;
}
interface JwtCredentials {
    type: AuthModes['Jwt'];
    privateKeyId?: string;
    issuerId?: string;
    privateKey: {
        id: string;
        secret: string;
    } | string;
    token?: string;
    expires_at?: Date | undefined;
}
interface BillCredentials extends CredentialsCommon {
    type: AuthModes['Bill'];
    username: string;
    password: string;
    organization_id: string;
    dev_key: string;
    session_id?: string;
    user_id?: string;
    expires_at?: Date | undefined;
}
interface TwoStepCredentials extends CredentialsCommon {
    type: AuthModes['TwoStep'];
    [key: string]: any;
    token?: string;
    expires_at?: Date | undefined;
}
interface SignatureCredentials {
    type: AuthModes['Signature'];
    username: string;
    password: string;
    token?: string;
    expires_at?: Date | undefined;
}
interface CustomCredentials extends CredentialsCommon {
    type: AuthModes['Custom'];
}
type UnauthCredentials = Record<string, never>;
type AuthCredentials = OAuth2Credentials | OAuth2ClientCredentials | OAuth1Credentials | BasicApiCredentials | ApiKeyCredentials | AppCredentials | AppStoreCredentials | UnauthCredentials | TbaCredentials | TableauCredentials | JwtCredentials | BillCredentials | TwoStepCredentials | SignatureCredentials | CustomCredentials;
type Metadata = Record<string, unknown>;
interface MetadataChangeResponse {
    metadata: Metadata;
    provider_config_key: string;
    connection_id: string | string[];
}
interface Connection {
    id: number;
    provider_config_key: string;
    connection_id: string;
    connection_config: Record<string, string>;
    created_at: string;
    updated_at: string;
    last_fetched_at: string;
    metadata: Record<string, unknown> | null;
    provider: string;
    errors: {
        type: string;
        log_id: string;
    }[];
    end_user: ApiEndUser | null;
    credentials: AuthCredentials;
}
export declare class ActionError<T = Record<string, unknown>> extends Error {
    type: string;
    payload?: Record<string, unknown>;
    constructor(payload?: T);
}
export interface NangoProps {
    scriptType: 'sync' | 'action' | 'webhook' | 'on-event';
    host?: string;
    secretKey: string;
    team?: Pick<DBTeam, 'id' | 'name'>;
    connectionId: string;
    environmentId: number;
    environmentName?: string;
    activityLogId?: string | undefined;
    providerConfigKey: string;
    provider: string;
    lastSyncDate?: Date;
    syncId?: string | undefined;
    nangoConnectionId?: number;
    syncJobId?: number | undefined;
    dryRun?: boolean;
    track_deletes?: boolean;
    attributes?: object | undefined;
    logMessages?:
    | {
        counts: {
            updated: number;
            added: number;
            deleted: number;
        };
        messages: unknown[];
    }
    | undefined;
    rawSaveOutput?: Map<string, unknown[]> | undefined;
    rawDeleteOutput?: Map<string, unknown[]> | undefined;
    stubbedMetadata?: Metadata | undefined;
    abortSignal?: AbortSignal;
    syncConfig: DBSyncConfig;
    runnerFlags: RunnerFlags;
    debug: boolean;
    startedAt: Date;
    endUser: {
        id: number;
        endUserId: string | null;
        orgId: string | null;
    } | null;
    axios?: {
        request?: AxiosInterceptorManager<AxiosRequestConfig>;
        response?: {
            onFulfilled: (value: AxiosResponse) => AxiosResponse | Promise<AxiosResponse>;
            onRejected: (value: unknown) => AxiosError | Promise<AxiosError>;
        };
    };
}
export interface EnvironmentVariable {
    name: string;
    value: string;
}
export declare const defaultPersistApi: AxiosInstance;
export declare class NangoAction {
    protected nango: Nango;
    private attributes;
    protected persistApi: AxiosInstance;
    activityLogId?: string | undefined;
    syncId?: string;
    nangoConnectionId?: number;
    environmentId: number;
    environmentName?: string;
    syncJobId?: number;
    dryRun?: boolean;
    abortSignal?: AbortSignal;
    syncConfig?: DBSyncConfig;
    runnerFlags: RunnerFlags;
    connectionId: string;
    providerConfigKey: string;
    provider?: string;
    ActionError: typeof ActionError;
    private memoizedConnections;
    private memoizedIntegration;
    constructor(
        config: NangoProps,
        {
            persistApi
        }?: {
            persistApi: AxiosInstance;
        }
    );
    protected stringify(): string;
    private proxyConfig;
    protected throwIfAborted(): void;
    proxy<T = any>(config: ProxyConfiguration): Promise<AxiosResponse<T>>;
    get<T = any>(config: Omit<ProxyConfiguration, 'method'>): Promise<AxiosResponse<T>>;
    post<T = any>(config: Omit<ProxyConfiguration, 'method'>): Promise<AxiosResponse<T>>;
    put<T = any>(config: Omit<ProxyConfiguration, 'method'>): Promise<AxiosResponse<T>>;
    patch<T = any>(config: Omit<ProxyConfiguration, 'method'>): Promise<AxiosResponse<T>>;
    delete<T = any>(config: Omit<ProxyConfiguration, 'method'>): Promise<AxiosResponse<T>>;
    getToken(): Promise<string | OAuth1Token | OAuth2ClientCredentials | BasicApiCredentials | ApiKeyCredentials | AppCredentials | AppStoreCredentials | UnauthCredentials | CustomCredentials | TbaCredentials | TableauCredentials | JwtCredentials | BillCredentials | TwoStepCredentials | SignatureCredentials>;
    /**
     * Get current integration
     */
    getIntegration(queries?: GetPublicIntegration['Querystring']): Promise<GetPublicIntegration['Success']['data']>;
    getConnection(providerConfigKeyOverride?: string, connectionIdOverride?: string): Promise<Connection>;
    setMetadata(metadata: Metadata): Promise<AxiosResponse<MetadataChangeResponse>>;
    updateMetadata(metadata: Metadata): Promise<AxiosResponse<MetadataChangeResponse>>;
    /**
     * @deprecated please use setMetadata instead.
     */
    setFieldMapping(fieldMapping: Record<string, string>): Promise<AxiosResponse<object>>;
    getMetadata<T = Metadata>(): Promise<T>;
    getWebhookURL(): Promise<string | null | undefined>;
    /**
     * @deprecated please use getMetadata instead.
     */
    getFieldMapping(): Promise<Metadata>;
    /**
     * Log
     * @desc Log a message to the activity log which shows up in the Nango Dashboard
     * note that the last argument can be an object with a level property to specify the log level
     * @example
     * ```ts
     * await nango.log('This is a log message', { level: 'error' })
     * ```
     */
    log(
        message: any,
        options?:
            | {
                level?: LogLevel;
            }
            | {
                [key: string]: any;
                level?: never;
            }
    ): Promise<void>;
    log(
        message: string,
        ...args: [
            any,
            {
                level?: LogLevel;
            }
        ]
    ): Promise<void>;
    getEnvironmentVariables(): Promise<EnvironmentVariable[] | null>;
    getFlowAttributes<A = object>(): A | null;
    paginate<T = any>(config: ProxyConfiguration): AsyncGenerator<T[], undefined, void>;
    triggerAction<In = unknown, Out = object>(providerConfigKey: string, connectionId: string, actionName: string, input?: In): Promise<Out>;
    zodValidateInput<T = any, Z = any>({ zodSchema, input }: { zodSchema: ZodSchema<Z>; input: T }): Promise<SafeParseSuccess<Z>>;
    triggerSync(providerConfigKey: string, connectionId: string, syncName: string, fullResync?: boolean): Promise<void | string>;
    startSync(providerConfigKey: string, syncs: (string | { name: string; variant: string })[], connectionId?: string): Promise<void>;
    /**
     * Uncontrolled fetch is a regular fetch without retry or credentials injection.
     * Only use that method when you want to access resources that are unrelated to the current connection/provider.
     */
    uncontrolledFetch(options: { url: URL; method?: HTTP_METHOD; headers?: Record<string, string> | undefined; body?: string | null }): Promise<Response>;
    private sendLogToPersist;
    private logAPICall;
}
export declare class NangoSync extends NangoAction {
    variant: string;
    lastSyncDate?: Date;
    track_deletes: boolean;
    logMessages?:
        | {
            counts: {
                updated: number;
                added: number;
                deleted: number;
            };
            messages: unknown[];
        }
        | undefined;
    rawSaveOutput?: Map<string, unknown[]>;
    rawDeleteOutput?: Map<string, unknown[]>;
    stubbedMetadata?: Metadata | undefined;
    private batchSize;
    constructor(config: NangoProps);
    /**
     * @deprecated please use batchSave
     */
    batchSend<T extends object>(results: T[], model: string): Promise<boolean | null>;
    batchSave<T extends object>(results: T[], model: string): Promise<boolean | null>;
    batchDelete<T extends object>(results: T[], model: string): Promise<boolean | null>;
    batchUpdate<T extends object>(results: T[], model: string): Promise<boolean | null>;
    getMetadata<T = Metadata>(): Promise<T>;
    setMergingStrategy(merging: { strategy: 'ignore_if_modified_after' | 'override' }, model: string): Promise<void>;
    getRecordsByIds<K = string | number, T = any>(ids: K[], model: string): Promise<Map<K, T>>;
}
/**
 * @internal
 *
 * This function will enable tracing on the SDK
 * It has been split from the actual code to avoid making the code too dirty and to easily enable/disable tracing if there is an issue with it
 */
export declare function instrumentSDK(rawNango: NangoAction | NangoSync): NangoAction | NangoSync;
export { };



// ------ /SDK

// ------ Flows
export const NangoFlows = [
  {
    "providerConfigKey": "google-mail",
    "syncs": [],
    "actions": [
      {
        "name": "compose-draft",
        "type": "action",
        "description": "Creates a new draft email in Gmail.",
        "version": "",
        "scopes": [
          "https://www.googleapis.com/auth/gmail.modify"
        ],
        "input": "GmailDraftInput",
        "output": [
          "GmailDraftOutput"
        ],
        "usedModels": [
          "GmailDraftOutput",
          "GmailDraftInput"
        ],
        "endpoint": {
          "method": "POST",
          "path": "/draft"
        }
      },
      {
        "name": "compose-draft-reply",
        "type": "action",
        "description": "Creates a new draft email that is a reply to an existing email.",
        "version": "",
        "scopes": [
          "https://www.googleapis.com/auth/gmail.modify"
        ],
        "input": "GmailReplyDraftInput",
        "output": [
          "GmailReplyDraftOutput"
        ],
        "usedModels": [
          "GmailReplyDraftOutput",
          "GmailReplyDraftInput"
        ],
        "endpoint": {
          "method": "POST",
          "path": "/draft-reply"
        }
      },
      {
        "name": "list-messages",
        "type": "action",
        "description": "Lists emails from Gmail inbox with optional filtering.",
        "version": "",
        "scopes": [
          "https://www.googleapis.com/auth/gmail.readonly"
        ],
        "input": "GmailListMessagesInput",
        "output": [
          "GmailMessageList"
        ],
        "usedModels": [
          "GmailMessageList",
          "GmailMessageMetadata",
          "GmailListMessagesInput"
        ],
        "endpoint": {
          "method": "GET",
          "path": "/list-messages"
        }
      },
      {
        "name": "get-message",
        "type": "action",
        "description": "Retrieves a specific email by ID.",
        "version": "",
        "scopes": [
          "https://www.googleapis.com/auth/gmail.readonly"
        ],
        "input": "GmailGetMessageInput",
        "output": [
          "GmailMessage"
        ],
        "usedModels": [
          "GmailMessage",
          "GmailHeader",
          "GmailAttachmentInfo",
          "GmailGetMessageInput"
        ],
        "endpoint": {
          "method": "GET",
          "path": "/get-message"
        }
      },
      {
        "name": "search-messages",
        "type": "action",
        "description": "Searches for emails in Gmail using a query string.",
        "version": "",
        "scopes": [
          "https://www.googleapis.com/auth/gmail.readonly"
        ],
        "input": "GmailSearchMessagesInput",
        "output": [
          "GmailMessageList"
        ],
        "usedModels": [
          "GmailMessageList",
          "GmailMessageMetadata",
          "GmailSearchMessagesInput"
        ],
        "endpoint": {
          "method": "GET",
          "path": "/search-messages"
        }
      },
      {
        "name": "send-email",
        "type": "action",
        "description": "Sends an email via Gmail.",
        "version": "",
        "scopes": [
          "https://www.googleapis.com/auth/gmail.send"
        ],
        "input": "GmailSendEmailInput",
        "output": [
          "GmailSendEmailOutput"
        ],
        "usedModels": [
          "GmailSendEmailOutput",
          "GmailSendEmailInput",
          "GmailAttachment"
        ],
        "endpoint": {
          "method": "POST",
          "path": "/send-email"
        }
      }
    ],
    "onEventScripts": {
      "post-connection-creation": [],
      "pre-connection-deletion": []
    }
  },
  {
    "providerConfigKey": "google-calendar",
    "syncs": [],
    "actions": [
      {
        "name": "create-event",
        "type": "action",
        "description": "Creates a new event in Google Calendar.",
        "version": "",
        "scopes": [
          "https://www.googleapis.com/auth/calendar",
          "https://www.googleapis.com/auth/calendar.events"
        ],
        "input": "GoogleCalendarEventInput",
        "output": [
          "GoogleCalendarEventOutput"
        ],
        "usedModels": [
          "GoogleCalendarEventOutput",
          "GoogleCalendarEventInput"
        ],
        "endpoint": {
          "method": "POST",
          "path": "/create-event"
        }
      },
      {
        "name": "update-event",
        "type": "action",
        "description": "Updates an existing event in Google Calendar.",
        "version": "",
        "scopes": [
          "https://www.googleapis.com/auth/calendar",
          "https://www.googleapis.com/auth/calendar.events"
        ],
        "input": "GoogleCalendarEventUpdateInput",
        "output": [
          "GoogleCalendarEventOutput"
        ],
        "usedModels": [
          "GoogleCalendarEventOutput",
          "GoogleCalendarEventUpdateInput"
        ],
        "endpoint": {
          "method": "PUT",
          "path": "/update-event"
        }
      },
      {
        "name": "list-calendars",
        "type": "action",
        "description": "Lists all calendars available to the authenticated user.",
        "version": "",
        "scopes": [
          "https://www.googleapis.com/auth/calendar.readonly"
        ],
        "input": null,
        "output": [
          "GoogleCalendarList"
        ],
        "usedModels": [
          "GoogleCalendarList"
        ],
        "endpoint": {
          "method": "GET",
          "path": "/list-calendars"
        }
      },
      {
        "name": "list-events",
        "type": "action",
        "description": "Lists events from a specified calendar with optional filtering.",
        "version": "",
        "scopes": [
          "https://www.googleapis.com/auth/calendar.readonly"
        ],
        "input": "GoogleCalendarEventsInput",
        "output": [
          "GoogleCalendarEventList"
        ],
        "usedModels": [
          "GoogleCalendarEventList",
          "GoogleCalendarEventsInput"
        ],
        "endpoint": {
          "method": "GET",
          "path": "/list-events"
        }
      }
    ],
    "onEventScripts": {
      "post-connection-creation": [],
      "pre-connection-deletion": []
    }
  },
  {
    "providerConfigKey": "google-sheet",
    "syncs": [],
    "actions": [
      {
        "name": "create-sheet",
        "type": "action",
        "description": "Creates a new Google Sheet with optional initial data.",
        "version": "",
        "scopes": [
          "https://www.googleapis.com/auth/spreadsheets",
          "https://www.googleapis.com/auth/drive.file"
        ],
        "input": "GoogleSheetCreateInput",
        "output": [
          "GoogleSheetCreateOutput"
        ],
        "usedModels": [
          "GoogleSheetCreateOutput",
          "GoogleSheetCreateInput",
          "GoogleSheetTab",
          "SheetData",
          "SheetRow"
        ],
        "endpoint": {
          "method": "POST",
          "path": "/create-sheet"
        }
      },
      {
        "name": "update-sheet",
        "type": "action",
        "description": "Updates an existing Google Sheet with new data.",
        "version": "",
        "scopes": [
          "https://www.googleapis.com/auth/spreadsheets",
          "https://www.googleapis.com/auth/drive.file"
        ],
        "input": "GoogleSheetUpdateInput",
        "output": [
          "GoogleSheetUpdateOutput"
        ],
        "usedModels": [
          "GoogleSheetUpdateOutput",
          "GoogleSheetUpdateInput",
          "SheetUpdate",
          "SheetData",
          "SheetRow"
        ],
        "endpoint": {
          "method": "POST",
          "path": "/update-sheet"
        }
      }
    ],
    "onEventScripts": {
      "post-connection-creation": [],
      "pre-connection-deletion": []
    }
  },
  {
    "providerConfigKey": "google-drive",
    "syncs": [],
    "actions": [
      {
        "name": "list-documents",
        "type": "action",
        "description": "Lists documents in Google Drive with optional filtering by folder ID and document type.",
        "version": "",
        "scopes": [
          "https://www.googleapis.com/auth/drive.readonly"
        ],
        "input": "ListDocumentsInput",
        "output": [
          "GoogleDriveDocumentList"
        ],
        "usedModels": [
          "GoogleDriveDocumentList",
          "GoogleDriveDocument",
          "ListDocumentsInput"
        ],
        "endpoint": {
          "method": "GET",
          "path": "/list-documents"
        }
      },
      {
        "name": "list-root-folders",
        "type": "action",
        "description": "Lists folders at the root level of Google Drive.",
        "version": "",
        "scopes": [
          "https://www.googleapis.com/auth/drive.readonly"
        ],
        "input": null,
        "output": [
          "GoogleDriveFolderList"
        ],
        "usedModels": [
          "GoogleDriveFolderList",
          "GoogleDriveFolder"
        ],
        "endpoint": {
          "method": "GET",
          "path": "/list-root-folders"
        }
      }
    ],
    "onEventScripts": {
      "post-connection-creation": [],
      "pre-connection-deletion": []
    }
  },
  {
    "providerConfigKey": "linkedin",
    "syncs": [],
    "actions": [
      {
        "name": "get-user-profile",
        "type": "action",
        "description": "Gets the authenticated user's profile information from LinkedIn.",
        "version": "",
        "scopes": [
          "r_liteprofile",
          "r_emailaddress"
        ],
        "input": null,
        "output": [
          "LinkedInUserProfile"
        ],
        "usedModels": [
          "LinkedInUserProfile"
        ],
        "endpoint": {
          "method": "GET",
          "path": "/get-user-profile"
        }
      }
    ],
    "onEventScripts": {
      "post-connection-creation": [],
      "pre-connection-deletion": []
    }
  },
  {
    "providerConfigKey": "twitter-v2",
    "syncs": [],
    "actions": [
      {
        "name": "send-post",
        "type": "action",
        "description": "Sends a new post to Twitter/X.",
        "version": "",
        "scopes": [
          "tweet.read",
          "tweet.write",
          "users.read"
        ],
        "input": "TwitterPostInput",
        "output": [
          "TwitterPostOutput"
        ],
        "usedModels": [
          "TwitterPostOutput",
          "TwitterPostInput"
        ],
        "endpoint": {
          "method": "POST",
          "path": "/send-post"
        }
      },
      {
        "name": "get-user-profile",
        "type": "action",
        "description": "Gets the authenticated user's profile information from Twitter/X.",
        "version": "",
        "scopes": [
          "users.read"
        ],
        "input": null,
        "output": [
          "TwitterUserProfile"
        ],
        "usedModels": [
          "TwitterUserProfile"
        ],
        "endpoint": {
          "method": "GET",
          "path": "/get-user-profile"
        }
      }
    ],
    "onEventScripts": {
      "post-connection-creation": [],
      "pre-connection-deletion": []
    }
  },
  {
    "providerConfigKey": "github",
    "syncs": [],
    "actions": [
      {
        "name": "list-repositories",
        "type": "action",
        "description": "Lists repositories for the authenticated user.",
        "version": "",
        "scopes": [
          "repo"
        ],
        "input": null,
        "output": [
          "GithubRepositoryList"
        ],
        "usedModels": [
          "GithubRepositoryList",
          "GithubRepository"
        ],
        "endpoint": {
          "method": "GET",
          "path": "/list-repositories"
        }
      },
      {
        "name": "get-repository",
        "type": "action",
        "description": "Gets a specific repository by owner and name.",
        "version": "",
        "scopes": [
          "repo"
        ],
        "input": "GithubRepositoryInput",
        "output": [
          "GithubRepository"
        ],
        "usedModels": [
          "GithubRepository",
          "GithubRepositoryInput"
        ],
        "endpoint": {
          "method": "GET",
          "path": "/get-repository"
        }
      },
      {
        "name": "create-repository",
        "type": "action",
        "description": "Creates a new repository for the authenticated user.",
        "version": "",
        "scopes": [
          "repo"
        ],
        "input": "GithubCreateRepositoryInput",
        "output": [
          "GithubRepository"
        ],
        "usedModels": [
          "GithubRepository",
          "GithubCreateRepositoryInput"
        ],
        "endpoint": {
          "method": "POST",
          "path": "/create-repository"
        }
      },
      {
        "name": "update-repository",
        "type": "action",
        "description": "Updates an existing repository.",
        "version": "",
        "scopes": [
          "repo"
        ],
        "input": "GithubUpdateRepositoryInput",
        "output": [
          "GithubRepository"
        ],
        "usedModels": [
          "GithubRepository",
          "GithubUpdateRepositoryInput"
        ],
        "endpoint": {
          "method": "PATCH",
          "path": "/update-repository"
        }
      },
      {
        "name": "delete-repository",
        "type": "action",
        "description": "Deletes a repository.",
        "version": "",
        "scopes": [
          "delete_repo"
        ],
        "input": "GithubRepositoryInput",
        "output": [
          "GithubDeleteRepositoryOutput"
        ],
        "usedModels": [
          "GithubDeleteRepositoryOutput",
          "GithubRepositoryInput"
        ],
        "endpoint": {
          "method": "DELETE",
          "path": "/delete-repository"
        }
      },
      {
        "name": "list-issues",
        "type": "action",
        "description": "Lists issues for a repository.",
        "version": "",
        "scopes": [
          "repo"
        ],
        "input": "GithubIssuesInput",
        "output": [
          "GithubIssueList"
        ],
        "usedModels": [
          "GithubIssueList",
          "GithubIssue",
          "GithubIssueCreator",
          "GithubIssueLabel",
          "GithubIssueAssignee",
          "GithubIssuesInput"
        ],
        "endpoint": {
          "method": "GET",
          "path": "/list-issues"
        }
      },
      {
        "name": "get-issue",
        "type": "action",
        "description": "Gets a specific issue by number.",
        "version": "",
        "scopes": [
          "repo"
        ],
        "input": "GithubIssueInput",
        "output": [
          "GithubIssue"
        ],
        "usedModels": [
          "GithubIssue",
          "GithubIssueCreator",
          "GithubIssueLabel",
          "GithubIssueAssignee",
          "GithubIssueInput"
        ],
        "endpoint": {
          "method": "GET",
          "path": "/get-issue"
        }
      },
      {
        "name": "create-issue",
        "type": "action",
        "description": "Creates a new issue in a repository.",
        "version": "",
        "scopes": [
          "repo"
        ],
        "input": "GithubCreateIssueInput",
        "output": [
          "GithubIssue"
        ],
        "usedModels": [
          "GithubIssue",
          "GithubIssueCreator",
          "GithubIssueLabel",
          "GithubIssueAssignee",
          "GithubCreateIssueInput"
        ],
        "endpoint": {
          "method": "POST",
          "path": "/create-issue"
        }
      },
      {
        "name": "update-issue",
        "type": "action",
        "description": "Updates an existing issue.",
        "version": "",
        "scopes": [
          "repo"
        ],
        "input": "GithubUpdateIssueInput",
        "output": [
          "GithubIssue"
        ],
        "usedModels": [
          "GithubIssue",
          "GithubIssueCreator",
          "GithubIssueLabel",
          "GithubIssueAssignee",
          "GithubUpdateIssueInput"
        ],
        "endpoint": {
          "method": "PATCH",
          "path": "/update-issue"
        }
      }
    ],
    "onEventScripts": {
      "post-connection-creation": [],
      "pre-connection-deletion": []
    }
  }
] as const;
// ------ /Flows
